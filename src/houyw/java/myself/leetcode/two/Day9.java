package houyw.java.myself.leetcode.two;

import houyw.common.TreeNode;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

/**
 * @Author: DELL
 * @Date: 2022/7/13 16:07
 * @Description:
 */
public class Day9 {


    /**
     * 给定一个二叉搜索树的根节点 root ，和一个整数 k ，请你设计一个算法查找其中第?k?个最小元素（从 1 开始计数）。
     * 示例 1：
     * 输入：root = [3,1,4,null,2], k = 1
     * 输出：1
     * 示例 2：
     * 输入：root = [5,3,6,2,4,null,null,1], k = 3
     * 输出：3
     * 提示：
     * 树中的节点数为 n 。
     * 1 <= k <= n <= 104
     * 0 <= Node.val <= 104
     * 进阶：如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 k 小的值，你将如何优化算法？
     */
    //常规解法
    public int kthSmallest(TreeNode root, int k) {
        List<Integer> list = new ArrayList<>();
        List<TreeNode> lst = new ArrayList<>();
        lst.add(root);
        while (lst.size() != 0) {
            List<TreeNode> l = new ArrayList<>();
            for (TreeNode node : lst) {
                list.add(node.val);
                if (node.left != null) {
                    l.add(node.left);
                }
                if (node.right != null) {
                    l.add(node.right);
                }
            }
            lst = l;
        }
        Collections.sort(list);
        return list.get(k - 1);
    }

    //进阶解法
    public int kthSmallest1(TreeNode root, int k) {
        List<TreeNode> lst = new ArrayList<>();
        List<Integer> list = new ArrayList<>();
        while(root.left!=null){
            lst.add(root);
            root = root.left;
        }
        list.add(root.val);
        while(root.right!=null){

        }
        return 0;
    }



    /**
     * 实现一个二叉搜索树迭代器类BSTIterator ，表示一个按中序遍历二叉搜索树（BST）的迭代器：
     * BSTIterator(TreeNode root) 初始化 BSTIterator 类的一个对象。BST 的根节点 root 会作为构造函数的一部分给出。
     * 指针应初始化为一个不存在于 BST 中的数字，且该数字小于 BST 中的任何元素。
     * boolean hasNext() 如果向指针右侧遍历存在数字，则返回 true ；否则返回 false 。
     * int next()将指针向右移动，然后返回指针处的数字。
     * 注意，指针初始化为一个不存在于 BST 中的数字，所以对 next() 的首次调用将返回 BST 中的最小元素。
     * 你可以假设?next()?调用总是有效的，也就是说，当调用 next()?时，BST 的中序遍历中至少存在一个下一个数字。
     * 示例：
     * 输入
     * ["BSTIterator", "next", "next", "hasNext", "next", "hasNext", "next", "hasNext", "next", "hasNext"]
     * [[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]
     * 输出
     * [null, 3, 7, true, 9, true, 15, true, 20, false]
     * 解释
     * BSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]);
     * bSTIterator.next();    // 返回 3
     * bSTIterator.next();    // 返回 7
     * bSTIterator.hasNext(); // 返回 True
     * bSTIterator.next();    // 返回 9
     * bSTIterator.hasNext(); // 返回 True
     * bSTIterator.next();    // 返回 15
     * bSTIterator.hasNext(); // 返回 True
     * bSTIterator.next();    // 返回 20
     * bSTIterator.hasNext(); // 返回 False
     * 提示：
     * 树中节点的数目在范围 [1, 105] 内
     * 0 <= Node.val <= 106
     * 最多调用 105 次 hasNext 和 next 操作
     * 进阶：
     * 你可以设计一个满足下述条件的解决方案吗？next() 和 hasNext() 操作均摊时间复杂度为 O(1) ，
     * 并使用 O(h) 内存。其中 h 是树的高度。
     */
    class BSTIterator {
        public List<Integer> list;
        public int index;

        public BSTIterator(TreeNode root) {
            index = 0;
            list = new ArrayList<>();
            List<TreeNode> lst = new ArrayList<>();
            lst.add(root);
            while (lst.size() != 0) {
                List<TreeNode> l = new ArrayList<>();
                for (TreeNode node : lst) {
                    list.add(node.val);
                    if (node.left != null) {
                        l.add(node.left);
                    }
                    if (node.right != null) {
                        l.add(node.right);
                    }
                }
                lst = l;
            }
            Collections.sort(list);
        }

        public int next() {
            return list.get(index++);
        }

        public boolean hasNext() {
            if (index < list.size()) {
                return true;
            }
            return false;
        }
    }
}
